//评测题目: 无
问题1：
统计一篇文章中每个单词出现的次数（文章大小超过10G），
例如输入：
If not now when , if not me who?
输出
if 2
not 2
now 1
when 1
me 1
who 1
备注：文章已做过预处理，已将所有标点符号替换为空格。


import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map.Entry;


public class CountWords {

  public static void main(String[] args) throws IOException {
    CountWords sw = new CountWords(10 * 1024 * 1024);// 用10M的缓冲读取文本文件
    sw.count("D:/10G.txt");
    sw.print();
  }

  public CountWords(int sz) {
    this.sz = sz;
  }

  final HashMap<String, Long> hashMap = new HashMap<>(1024);
  final int sz;


  public void count(String src) throws IOException {
    File file = new File(src);
    if (!file.exists()) {
      System.out.println("文件不存在");
      return;
    }

    BufferedInputStream fis = new BufferedInputStream(new FileInputStream(file));
    BufferedReader reader = new BufferedReader(new InputStreamReader(fis, StandardCharsets.UTF_8),
        sz);//

    String line;
    while ((line = reader.readLine()) != null) {
      String[] lineWords = line.split(" ");

      for (String lineWord : lineWords) {
        lineWord = lineWord.trim();
        if ("".equals(lineWord)) {
          continue;
        }
        //如果已经有这个单词了，
        if (hashMap.containsKey(lineWord)) {
          long number = hashMap.get(lineWord);
          hashMap.put(lineWord, number + 1);
        } else {
          hashMap.put(lineWord, 1L);
        }
      }

    }
    System.out.println("文件统计结束");
  }

  public void print() {
    System.out.println("-----------统计单词完成，所有文件单词总数为-------------------");
    for (Entry<String, Long> wordCount : hashMap.entrySet()) {
      System.out.printf("单词:%-12s 出现次数:%d\n", wordCount.getKey(), wordCount.getValue());
    }
  }
}


问题2：
现需做一个部门管理功能，如公司有多个大部门A、B、C...，每个部门下面有多个子部门，子部门还有子部门以此类推，
如部门A下面有部门AB、AC、AD，部门AB下面有AE、AF，部门AC下面有AG、AH、AI，部门AE下面有AJ等，每个部门的子部门个数和部门的层数均为无限，
每个部门的父部门要么没有要么是一个。
针对上述需求完成如下题目：
1，设计表结构存储上述部门关系；
2，定义领域模型Department类；
3，实现删除部门方法：void delete(Integer departmentId)，要求删除指定部门的同时删除其下面的所有层级的子部门，
   如删除部门AB的同时要删除它的子部门AE、AF和AE的子部门AJ；
4，实现获取所有部门信息及其关系的方法：List<Department> getDepartments()；
备注：第3、第4问代码中涉及到的DB操作用一段注释或SQL表明是什么DB操作即可

CREATE TABLE `test`.`dept`(
  `department_Id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '部门id',
  `department_name` VARCHAR(50) NOT NULL COMMENT '部门名称',
  `parent_department_Id` BIGINT NOT NULL COMMENT '上级部门id',
  PRIMARY KEY (`department_Id`)
);


public class Department {

  private long departmentId;
  private String departmentName;
  private long parenDepartmentId;

  void delete(Integer departmentId) {
    Department department = null;//  sql 查询 departmentId
    if (department == null) {
      // 根据场景返回异常
      return;
    }

    // 获取所有下级部门 id
    List<Long> ids = new ArrayList<>();
    ids.add(department.departmentId);
    List<Long> current = new ArrayList<>();
    current.add(department.departmentId);
    do {
      // sql 通过 current 获取所有下级 部门
      List<Department> subDepartment = null;
      current.clear();
      if (subDepartment != null && !subDepartment.isEmpty()) {
        for (Department department1 : subDepartment) {
          ids.add(department1.departmentId);
          current.add(department1.departmentId);
        }
      }
    } while (!current.isEmpty());

    // sql 删除所有 ids 中的部门

  }

  List<Department> getDepartments() {
    // 查询 parent_department_Id == 0 的所有部门
    // 可以调用每个对象的 #getSubDepartment 方法获取下级部门
    return null;
  }

  List<Department> getSubDepartment() {
    // sql 查询下一级 department
  }

}
